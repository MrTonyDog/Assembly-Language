特殊的寄存器Flag寄存器:
    用来存储相关指令的某些执行结果
    用来为CPU执行相关指令提供行为依据
    用来控制CPU的相关工作方式

8086CPU有16位，其中存储的信息通常被称为程序状态字(PSW) 

Flag寄存器是按位起作用,它的每一位都有专门的含义，记录特定的信息.

8086CPU的Flag寄存器的结构如下:
    15  14  13  12  11  10  9   8   7   6   5   4   3   2   1   0
                    OF  DF  IF  TF  SF  ZF      AF      PF      CF 


根据上图得知 Flag的1,3,5,12,13,14,15位在8086CPU中没有作用


ZF:零标志位,它记录相关指令执行后，其结果是否为0，如果结果为0，那么ZF=1 , 
    如果结果不为0，那么ZF=0

    注意，在8086CPU的指令集中，有的指令的执行是影响标志寄存器，
    比如 add,sub,mul,div,inc,or,and等.他们大都是运算指令(进行逻辑或算术运算)
    有的指令的执行对标志寄存器没有影响，比如mov,push,pop等.它们大都是传送指令.
    在使用一条指令的时候，要注意这条指令的全部功能，其中包括，执行结果对标志寄存器的哪些标志位造成影响.


PF:Flag的第2位是PF，奇偶标志位，它记录相关指令执行后，其结果的所有bit位中1的个数是否
   为偶数，如果1的个数为偶函，PF=1,如果为奇数，那么PF=0

   比如:    mov al,1
            or al,2         执行结果为0000 0011B ,其中有2(偶数) 个1 ，则PF=1



SF:Flag的第七位是SF，符号标志位，它记录相关指令执行后，其结果是否为负数，
   如果结果为负数，则SF=1 , 如果非负数，则SF=0

   因为一个数值可以有符号和无符号，所以不管我们如何看待，CPU在执行add 等指令的时候
   就包含了两种含义，也将得到用同一种信息来记录的两种记录.关键在于我们的程序需要哪一种结果.

   那么对于SF标志来说，就是CPU对有符号数运算结果的一种记录，它记录数据的正负，
   在我们将数据当做有符号数来运算的时候，可以通过它来得知结果的正负。
   如果我们将数据当做无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值

   这也就是说CPU在执行add 等指令时，是必然要影响SF标志位的值


某些指令将影响标志寄存器中的多个标记位.

CF:Flag的第0位是CF，进位标志位。一般情况下，在进行[无符号数]运算的时候，
    它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值.

    CF记录了从最高有效位向更高位的进位值

    当两个数据做加法或减法(即借位和进位)，都会改变CF的值。


OF:在进行有符号数运算的时候，如果结果超过了机器所能表示的范围称为溢出

    如果运算结果超出了机器所能表达的范围，将产生溢出.(注意，这里所讲的溢出，只是对有符号数运算而言)
    如果在进行有符号数运算时发生了溢出，那么运算的结果将不正确.


    总而言之,对于无符号数运算，CPU用CF位来记录是否产生了进位，
对于有符号数运算，CPU用OF位来记录是否产生了溢出,当然还需要用SF位来记录结果的符号.
    可以看出，CF和OF所表示的进位和溢出，是分别对无符号数和有符号数运算而言的,他们之间没有任何关系


adc指令:带进位加法，它利用了CF位上记录的进位值.
指令格式:adc 操作对象1, 操作对象2
功能:操作对象1 = 操作对象1 + 操作对象2 +CF
比如指令adc ax,bx 实现的功能是: (ax)=(ax)+(bx)+CF

加法可以分两步来进行:1.低位相加 2.高位相加再加上低位相加产生的进位值
CPU提供adc命令的目的，就是来进行加法的第二步运算的,
下面我们来看一个例子：

编程计算    1EF000H + 201000H ,结果放在ax(高16位)和bx(低16位)中
    因为两个数据的位数都大于16，用add指令无法进行计算。我们将计算分两步进行
先将低16位相加，然后将高16位和进位值相加.程序如下:
    mov ax,001EH
    mov bx,0F000H
    add bx,1000H 
    adc ax,0020H

    adc 指令执行后，也可能产生进位值，所以也会对CF位进行设置。由于有这样的功能
    所以我们可以对任意大的数据进行加法运算(重要!,也就是前面写的divdw函数的优化)


sbb指令:sbb是带借位减法指令,它利用了CF位上记录的借位值.
指令格式:sbb 操作对象1，操作对象2
功能:操作对象1 = 操作对象1 - 操作对象2 -CF
比如指令 sbb ax,bx 实现的功能是: (ax)=(ax)-(bx)-CF

sbb指令执行后，将对CF进行设置，利用sbb指令可以对任意大的数据进行减法运算.
比如,计算003E 1000H - 0020 2000H ,结果放在ax,bx中，
程序如下:       mov bx,1000H
                mov ax,003EH
                sub bx,2000H
                sbb ax,0020H


sbb和adc是基于同样的思想设计的两条指令





